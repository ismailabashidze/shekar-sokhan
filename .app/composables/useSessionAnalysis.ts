import { useNuxtApp, useRuntimeConfig } from '#app'
import { ref } from 'vue'

export interface DemographicData {
  firstName: string
  lastName: string
  age: number
  gender: 'male' | 'female' | 'other'
  education:
    | 'under diploma'
    | 'diploma'
    | 'bachelor'
    | 'master'
    | 'phd'
    | 'other'
  occupation:
    | 'student'
    | 'employed'
    | 'self-employed'
    | 'single'
    | 'married'
    | 'divorced'
    | 'widowed'
  maritalStatus: 'single' | 'married' | 'divorced' | 'widowed'
}

export interface SessionAnalysis {
  id: string
  session: string
  title: string
  summaryOfSession: string
  headlines: Array<{
    title: string
    description: string
  }>
  finalTrustAndOppennessOfUser: 'veryHigh' | 'high' | 'low' | 'veryLow'
  finalTrustAndOppennessOfUserEvaluationDescription: string
  psychotherapistEvaluation: string
  negativeScoresList: Array<{
    points: number
    cause: string
  }>
  psychotherapistEvaluationScorePositiveBehavior: string[]
  psychotherapistEvaluationScoreSuggestionsToImprove: string[]
  behavioralAnalysisSummary: string
  emotionalAnalysisSummary: string
  thoughtsAndConcernsSummary: string
  psychoAnalysis: string
  possibleDeeperGoalsOfPatient: string
  detectedDefenceMechanisms: Array<{
    name: string
    confidence: 'very_low' | 'low' | 'high' | 'very_high'
    evidence: string
  }>
  detectedSchemas: Array<{
    name: string
    confidence: 'very_low' | 'low' | 'high' | 'very_high'
    evidence: string
  }>
  demographicData: DemographicData
  suggestedNextStepsForTherapistForNextSession: Array<{
    title: string
    description: string
    suggestedMessage?: string
    schedule?: {
      label: string
      hours: number
    }
    scheduledDate?: Date
    status?: string
  }>
  possibleRiskFactorsExtracted: Array<{
    title: string
    description: string
  }>
  notificationsCreated?: boolean
  created: string
  updated: string
  expand: any
}

export const useSessionAnalysis = () => {
  const nuxtApp = useNuxtApp()
  const pb = nuxtApp.$pb
  const error = ref<string | null>(null)
  const processing = ref(false)

  const createAnalysis = async (data: Partial<SessionAnalysis>) => {
    try {
      return await pb.collection('session_analysis_for_system').create(data)
    } catch (error: any) {
      console.error('Error creating session analysis:', error)
      throw error
    }
  }

  const getAnalysisById = async (id: string) => {
    try {
      return await pb.collection('session_analysis_for_system').getOne(id, {
        expand: 'session, session.user, session.therapist',
      })
    } catch (error: any) {
      console.error('Error getting session analysis:', error)
      throw error
    }
  }

  const listAnalysis = async (filter = '', sort = '-created') => {
    try {
      return await pb.collection('session_analysis_for_system').getList(1, 50, {
        filter,
        sort,
      })
    } catch (error: any) {
      console.error('Error listing session analysis:', error)
      throw error
    }
  }

  const updateAnalysis = async (id: string, data: Partial<SessionAnalysis>) => {
    try {
      return await pb.collection('session_analysis_for_system').update(id, data)
    } catch (error: any) {
      console.error('Error updating session analysis:', error)
      throw error
    }
  }

  const deleteAnalysis = async (id: string) => {
    try {
      return await pb.collection('session_analysis_for_system').delete(id)
    } catch (error: any) {
      console.error('Error deleting session analysis:', error)
      throw error
    }
  }

  // Helper function to make API requests to OpenRouter
  const makeOpenRouterRequest = async (
    messages: any[],
    schema: any,
    maxTokens = 1000,
  ) => {
    // Try a more reliable model first
    const models = ['google/gemma-3-27b-it']
    let currentModelIndex = 0
    
    const requestBody = (model: string) => ({
      model,
      messages,
      response_format: {
        type: 'json_schema',
        json_schema: {
          name: 'session_analysis_part',
          strict: true,
          schema,
        },
      },
      temperature: 0.7,
      // Increase max_tokens significantly and add a buffer
      max_tokens: maxTokens * 2, // Double the tokens to prevent truncation
      plugins: [],
      transforms: ['middle-out'],
    })

    // Implement timeout mechanism similar to useOpenRouter.ts
    let response: Response | null = null
    let attempts = 0
    const maxAttempts = 3 // Initial attempt + 2 retries
    const startTime = Date.now()

    while (attempts < maxAttempts) {
      attempts++
      const attemptStartTime = Date.now()
      const elapsedSinceStart = Math.round(
        (attemptStartTime - startTime) / 1000,
      )
      console.log(
        `‚è≥ Attempt ${attempts}/${maxAttempts} to generate session analysis part (Elapsed: ${elapsedSinceStart}s)`,
      )

      try {
        // Use a custom HTTP agent to handle HTTP2 protocol issues
        const controller = new AbortController()
        const timeoutId = setTimeout(() => controller.abort(), 120000) // 120 second timeout

        const currentModel = models[currentModelIndex]
        console.log(`üîÑ Trying model: ${currentModel} with max_tokens: ${maxTokens * 2}`)
        
        response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${
              useRuntimeConfig().public.openRouterApiKey
            }`,
            'HTTP-Referer':
              useRuntimeConfig().public.appUrl || 'http://localhost:3000',
            'X-Title': 'Session Analysis Generator',
          },
          body: JSON.stringify(requestBody(currentModel)),
          signal: controller.signal,
        })

        clearTimeout(timeoutId)

        console.log(`‚úÖ Request successful on attempt ${attempts}`)
        // If we get here, the request was successful
        // Check if response is valid before breaking
        if (response && response.ok) {
          break
        } else if (response) {
          // If response exists but is not ok, throw error to trigger retry
          const errorText = await response.text()
          throw new Error(`HTTP ${response.status}: ${errorText}`)
        }
      } catch (e: any) {
        console.log(`‚ùå Attempt ${attempts} failed:`, e)
        
        // Handle specific network errors
        if (e.name === 'AbortError') {
          console.log('‚è∞ Request timeout after 120 seconds')
          throw new Error('Request timeout after 120 seconds')
        }
        
        // Handle network errors that might be related to HTTP2
        if (e.message && (e.message.includes('HTTP2') || e.message.includes('net::'))) {
          console.log('üîÑ HTTP/2 protocol error detected, trying different model...')
          // Try with a different model on HTTP2 errors
          if (currentModelIndex < models.length - 1) {
            currentModelIndex++
            console.log(`üîÑ Switching to model: ${models[currentModelIndex]}`)
            attempts = 0 // Reset attempts when switching models
            continue
          }
        }
        
        if (attempts >= maxAttempts) {
          // Last attempt failed, re-throw the error
          throw e
        }
        // Retry after 1 second
        console.log('üîÑ Retrying in 1 second...')
        await new Promise(resolve => setTimeout(resolve, 1000))
      }
    }

    // Additional check to ensure we have a valid response
    if (!response) {
      throw new Error('No response received from OpenRouter API after all attempts')
    }

    if (!response.ok) {
      const errorText = await response.text()
      let errorMessage: string
      try {
        const errorData = JSON.parse(errorText)
        errorMessage = errorData?.error?.message || errorData?.message || errorText
      } catch {
        errorMessage = errorText
      }
      throw new Error(`OpenRouter API error: ${errorMessage}`)
    }

    const data = await response.json()
    const content = data.choices[0]?.message?.content

    // Validate that we have content to parse
    if (!content) {
      console.error('No content in response:', data)
      throw new Error('Empty response content from OpenRouter API')
    }

    // Parse the JSON response with better error handling
    try {
      // Handle case where content might be wrapped in markdown code blocks
      let cleanedContent = content.trim()
      if (cleanedContent.startsWith('```json')) {
        cleanedContent = cleanedContent.substring(7).trim()
      }
      if (cleanedContent.startsWith('```')) {
        cleanedContent = cleanedContent.substring(3).trim()
      }
      if (cleanedContent.endsWith('```')) {
        cleanedContent = cleanedContent.slice(0, -3).trim()
      }
      
      // Handle truncated JSON responses
      let parsed
      try {
        parsed = typeof cleanedContent === 'string' ? JSON.parse(cleanedContent) : cleanedContent
      } catch (parseError: any) {
        // If JSON parsing fails due to truncation, try to fix common truncation issues
        console.warn('JSON parsing failed, attempting to fix truncated response...')
        
        // Try to fix truncated strings by closing them
        let fixedContent = cleanedContent
        
        // Check if we have an unterminated string (most common issue)
        const quoteCount = (fixedContent.match(/"/g) || []).length
        if (quoteCount % 2 !== 0) {
          // We have an odd number of quotes, likely an unterminated string
          console.log('Detected unterminated string, attempting to fix...')
          
          // Find the last quote and see if it's properly closed
          const lastQuoteIndex = fixedContent.lastIndexOf('"')
          if (lastQuoteIndex > 0) {
            // Check if there's a comma or closing brace/bracket after the last quote
            const afterQuote = fixedContent.substring(lastQuoteIndex + 1)
            if (afterQuote.trim() === '' || 
                (afterQuote.trim().startsWith('}') && !afterQuote.includes('{')) ||
                (afterQuote.trim().startsWith(']') && !afterQuote.includes('['))) {
              // Likely an unterminated string, try to close it
              fixedContent = fixedContent.substring(0, lastQuoteIndex + 1) + 
                            '"' + 
                            fixedContent.substring(lastQuoteIndex + 1)
            }
          }
        }
        
        // Try to find the last complete object or array and close it properly
        const braceStack: string[] = []
        let inString = false
        let escapeNext = false
        
        for (let i = 0; i < fixedContent.length; i++) {
          const char = fixedContent[i]
          
          if (escapeNext) {
            escapeNext = false
            continue
          }
          
          if (char === '\\\\') {
            escapeNext = true
            continue
          }
          
          if (char === '"' && !escapeNext) {
            inString = !inString
            continue
          }
          
          if (inString) continue
          
          if (char === '{' || char === '[') {
            braceStack.push(char)
          } else if (char === '}' || char === ']') {
            if (braceStack.length > 0) {
              braceStack.pop()
            }
          }
        }
        
        // Close any unclosed braces/brackets
        while (braceStack.length > 0) {
          const lastOpen = braceStack.pop()
          if (lastOpen === '{') {
            fixedContent += '}'
          } else if (lastOpen === '[') {
            fixedContent += ']'
          }
        }
        
        // Try parsing the fixed content
        try {
          parsed = JSON.parse(fixedContent)
          console.log('‚úÖ Successfully parsed fixed JSON response')
        } catch (fixedParseError) {
          console.error('Failed to parse fixed JSON response:', fixedContent)
          throw new Error(`Invalid JSON response even after fixing: ${fixedParseError.message}. Original error: ${parseError.message}`)
        }
      }
      
      return parsed
    } catch (e: any) {
      console.error('Failed to parse JSON response:', content)
      console.error('Cleaned content:', cleanedContent)
      // Return a default structure to prevent complete failure
      throw new Error(`Invalid JSON response: ${e.message}. Response content: ${content.substring(0, 200)}...`)
    }
  }

  // Individual analysis functions
  const getSessionOverview = async (messages: any[]) => {
    const systemMessage =
      'ÿ¥ŸÖÿß €å⁄© ÿØÿ≥ÿ™€åÿßÿ± ÿ™ÿ≠ŸÑ€åŸÑ⁄Øÿ± ÿ¨ŸÑÿ≥ÿßÿ™ ÿ±ŸàÿßŸÜÿ¥ŸÜÿßÿ≥€å Ÿáÿ≥ÿ™€åÿØ. ŸÑÿ∑ŸÅÿß ÿ®ÿß ÿ®ÿ±ÿ±ÿ≥€å Ÿæ€åÿßŸÖ‚ÄåŸáÿß€å ÿ¨ŸÑÿ≥Ÿáÿå ÿπŸÜŸàÿßŸÜÿå ÿÆŸÑÿßÿµŸá Ÿà ÿ™€åÿ™ÿ±Ÿáÿß€å ÿ¨ŸÑÿ≥Ÿá ÿ±ÿß ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ⁄©ŸÜ€åÿØ. ÿÆÿ±Ÿàÿ¨€å ÿ¥ŸÖÿß ÿ®ÿß€åÿØ ÿ®Ÿá ÿ¥⁄©ŸÑ JSON ÿ®ÿßÿ¥ÿØ. ÿß€åŸÜ json ÿ®ÿß€åÿØ ŸÖÿπÿ™ÿ®ÿ± ÿ®ÿßÿ¥ÿØ. ÿ™ŸÖÿßŸÖ Ÿæÿßÿ≥ÿÆ‚ÄåŸáÿß ÿ®ÿß€åÿØ ÿ®Ÿá ÿ≤ÿ®ÿßŸÜ ŸÅÿßÿ±ÿ≥€å ÿ®ÿßÿ¥ŸÜÿØ Ÿà ÿ™ŸÖÿßŸÖ ŸÖŸÇÿßÿØ€åÿ± ÿ±ÿ¥ÿ™Ÿá‚Äåÿß€å ÿ®ÿß€åÿØ ÿ®Ÿá ÿπŸÜŸàÿßŸÜ ŸÖÿ™ŸÜ ÿ®ÿßÿ¥ŸÜÿØ.'

    const schema = {
      type: 'object',
      properties: {
        title: {
          type: 'string',
          description:
            'ÿπŸÜŸàÿßŸÜ €åÿß ŸÖŸàÿ∂Ÿàÿπ ÿ¨ŸÑÿ≥Ÿáÿå ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ŸÖÿ≠ÿ™Ÿàÿß Ÿà ŸÖŸàÿ∂Ÿàÿπÿßÿ™ ŸÖÿ∑ÿ±ÿ≠ ÿ¥ÿØŸá ÿØÿ± ÿ¨ŸÑÿ≥Ÿá',
        },
        summaryOfSession: {
          type: 'string',
          description: 'ÿÆŸÑÿßÿµŸá ÿ¨ÿßŸÖÿπ€å ÿßÿ≤ ÿ¨ŸÑÿ≥Ÿá ÿØÿ±ŸÖÿßŸÜ€å',
          maxLength: 1000,
        },
        headlines: {
          type: 'array',
          description:
            'ŸÅŸáÿ±ÿ≥ÿ™€å ÿØŸÇ€åŸÇÿßŸã ÿ¥ÿßŸÖŸÑ €¥ ÿ™€åÿ™ÿ± ⁄©Ÿá ÿ¨ŸÑÿ≥Ÿá ÿØÿ±ŸÖÿßŸÜ€å ÿ±ÿß ŸÜÿ¥ÿßŸÜ ŸÖ€å ÿØŸáÿØ',
          items: {
            type: 'object',
            properties: {
              title: { type: 'string' },
              description: { type: 'string' },
            },
            required: ['title', 'description'],
          },
          minItems: 4,
          maxItems: 4,
        },
      },
      required: ['title', 'summaryOfSession', 'headlines'],
    }

    // Reduce max tokens to prevent truncation
    return await makeOpenRouterRequest(
      [
        { role: 'system', content: systemMessage },
        {
          role: 'user',
          content: `ŸÑÿ∑ŸÅÿß Ÿæ€åÿßŸÖ‚ÄåŸáÿß€å ÿ≤€åÿ± ÿ±ÿß ÿ™ÿ≠ŸÑ€åŸÑ ⁄©ŸÜ€åÿØ:\n${messages
            .map((m) => `${m.role}: ${m.content}`)
            .join('\n')}`,
        },
      ],
      schema,
      500, // Reduced from 800 to 500 to prevent truncation
    )
  }

  const getTrustAndOpennessAnalysis = async (messages: any[]) => {
    const systemMessage =
      'ÿ¥ŸÖÿß €å⁄© ÿØÿ≥ÿ™€åÿßÿ± ÿ™ÿ≠ŸÑ€åŸÑ⁄Øÿ± ÿ¨ŸÑÿ≥ÿßÿ™ ÿ±ŸàÿßŸÜÿ¥ŸÜÿßÿ≥€å Ÿáÿ≥ÿ™€åÿØ. ŸÑÿ∑ŸÅÿß ÿ≥ÿ∑ÿ≠ ÿßÿπÿ™ŸÖÿßÿØ Ÿà ÿµÿ±ÿßÿ≠ÿ™ ⁄©ÿßÿ±ÿ®ÿ± ÿ±ÿß ŸÜÿ≥ÿ®ÿ™ ÿ®Ÿá ÿ±ŸàÿßŸÜ ÿ¥ŸÜÿßÿ≥ ŸáŸàÿ¥ ŸÖÿµŸÜŸàÿπ€å ÿ™ÿ≠ŸÑ€åŸÑ ⁄©ŸÜ€åÿØ. ÿÆÿ±Ÿàÿ¨€å ÿ¥ŸÖÿß ÿ®ÿß€åÿØ ÿ®Ÿá ÿ¥⁄©ŸÑ JSON ÿ®ÿßÿ¥ÿØ. ÿß€åŸÜ json ÿ®ÿß€åÿØ ŸÖÿπÿ™ÿ®ÿ± ÿ®ÿßÿ¥ÿØ. ÿ™ŸÖÿßŸÖ Ÿæÿßÿ≥ÿÆ‚ÄåŸáÿß ÿ®ÿß€åÿØ ÿ®Ÿá ÿ≤ÿ®ÿßŸÜ ŸÅÿßÿ±ÿ≥€å ÿ®ÿßÿ¥ŸÜÿØ Ÿà ÿ™ŸÖÿßŸÖ ŸÖŸÇÿßÿØ€åÿ± ÿ±ÿ¥ÿ™Ÿá‚Äåÿß€å ÿ®ÿß€åÿØ ÿ®Ÿá ÿπŸÜŸàÿßŸÜ ŸÖÿ™ŸÜ ÿ®ÿßÿ¥ŸÜÿØ.'

    const schema = {
      type: 'object',
      properties: {
        finalTrustAndOppennessOfUser: {
          type: 'string',
          enum: ['veryHigh', 'high', 'low', 'veryLow'],
          description:
            'ÿ≥ÿ∑ÿ≠ ÿßÿπÿ™ŸÖÿßÿØ Ÿà ÿµÿ±ÿßÿ≠ÿ™€å ⁄©Ÿá ⁄©ÿßÿ±ÿ®ÿ± ŸÜÿ≥ÿ®ÿ™ ÿ®Ÿá ÿß€åŸÜ ÿ±ŸàÿßŸÜ ÿ¥ŸÜÿßÿ≥ ŸáŸàÿ¥ ŸÖÿµŸÜŸàÿπ€å ÿØÿ± ÿ∑ŸàŸÑ ÿß€åŸÜ ÿ¨ŸÑÿ≥Ÿá ŸÜÿ¥ÿßŸÜ ÿØÿßÿØŸá ÿßÿ≥ÿ™',
        },
        finalTrustAndOppennessOfUserEvaluationDescription: {
          type: 'string',
          description:
            'ÿ™Ÿàÿ∂€åÿ≠ ÿØŸÇ€åŸÇ ÿßÿ±ÿ≤€åÿßÿ®€å ÿßÿπÿ™ŸÖÿßÿØ Ÿà ÿµÿ±ÿßÿ≠ÿ™ ÿ®Ÿá ŸáŸÖÿ±ÿßŸá ÿ¥ŸàÿßŸáÿØ€å ÿØÿ±ÿ®ÿßÿ±Ÿá ÿßÿπÿ™ŸÖÿßÿØ Ÿà ÿµÿ±ÿßÿ≠ÿ™ ⁄©ÿßÿ±ÿ®ÿ± ŸÜÿ≥ÿ®ÿ™ ÿ®Ÿá ÿß€åŸÜ ÿ±ŸàÿßŸÜ ÿ¥ŸÜÿßÿ≥ ŸáŸàÿ¥ ŸÖÿµŸÜŸàÿπ€å',
        },
      },
      required: [
        'finalTrustAndOppennessOfUser',
        'finalTrustAndOppennessOfUserEvaluationDescription',
      ],
    }

    // Reduce token limit to prevent truncation and allow buffer
    return await makeOpenRouterRequest(
      [
        { role: 'system', content: systemMessage },
        {
          role: 'user',
          content: `ŸÑÿ∑ŸÅÿß Ÿæ€åÿßŸÖ‚ÄåŸáÿß€å ÿ≤€åÿ± ÿ±ÿß ÿ™ÿ≠ŸÑ€åŸÑ ⁄©ŸÜ€åÿØ:\n${messages
            .map((m) => `${m.role}: ${m.content}`)
            .join('\n')}`,
        },
      ],
      schema,
      400, // Significantly reduced from 800 to 400 to prevent truncation
    )
  }

  const getTherapistEvaluation = async (messages: any[]) => {
    const systemMessage =
      'ÿ¥ŸÖÿß €å⁄© ÿØÿ≥ÿ™€åÿßÿ± ÿ™ÿ≠ŸÑ€åŸÑ⁄Øÿ± ÿ¨ŸÑÿ≥ÿßÿ™ ÿ±ŸàÿßŸÜÿ¥ŸÜÿßÿ≥€å Ÿáÿ≥ÿ™€åÿØ. ŸÑÿ∑ŸÅÿß ÿπŸÖŸÑ⁄©ÿ±ÿØ ÿ±ŸàÿßŸÜ ÿ¥ŸÜÿßÿ≥ ÿ±ÿß ÿßÿ±ÿ≤€åÿßÿ®€å ⁄©ŸÜ€åÿØ. ÿÆÿ±Ÿàÿ¨€å ÿ¥ŸÖÿß ÿ®ÿß€åÿØ ÿ®Ÿá ÿ¥⁄©ŸÑ JSON ÿ®ÿßÿ¥ÿØ. ÿß€åŸÜ json ÿ®ÿß€åÿØ ŸÖÿπÿ™ÿ®ÿ± ÿ®ÿßÿ¥ÿØ. ÿ™ŸÖÿßŸÖ Ÿæÿßÿ≥ÿÆ‚ÄåŸáÿß ÿ®ÿß€åÿØ ÿ®Ÿá ÿ≤ÿ®ÿßŸÜ ŸÅÿßÿ±ÿ≥€å ÿ®ÿßÿ¥ŸÜÿØ Ÿà ÿ™ŸÖÿßŸÖ ŸÖŸÇÿßÿØ€åÿ± ÿ±ÿ¥ÿ™Ÿá‚Äåÿß€å ÿ®ÿß€åÿØ ÿ®Ÿá ÿπŸÜŸàÿßŸÜ ŸÖÿ™ŸÜ ÿ®ÿßÿ¥ŸÜÿØ.'

    const schema = {
      type: 'object',
      properties: {
        psychotherapistEvaluation: {
          type: 'string',
          description: 'ÿßÿ±ÿ≤€åÿßÿ®€å ÿ¨ÿßŸÖÿπ ÿπŸÖŸÑ⁄©ÿ±ÿØ ÿ±ŸàÿßŸÜ ÿ¥ŸÜÿßÿ≥',
        },
        negativeScoresList: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              points: {
                type: 'number',
                description:
                  'ÿ™ÿπÿØÿßÿØ ÿßŸÖÿ™€åÿßÿ≤ÿßÿ™ ⁄©ÿ≥ÿ± ÿ¥ÿØŸá ÿ®ÿ±ÿß€å ÿßÿ¥ÿ™ÿ®ÿßŸá €åÿß ÿÆÿ∑ÿß€å ÿ±ŸàÿßŸÜ ÿ¥ŸÜÿßÿ≥. ÿ™Ÿàÿ¨Ÿá ÿØÿßÿ¥ÿ™Ÿá ÿ®ÿßÿ¥€åÿØ ⁄©Ÿá ÿß€åŸÜ ÿßÿ¥ÿ™ÿ®ÿßŸáÿßÿ™ ÿ≠ÿ±ŸÅŸá ÿß€å Ÿáÿ≥ÿ™ŸÜÿØ Ÿà ÿ®ÿß€åÿØ ÿØŸÇ€åŸÇ Ÿà ŸÖÿ≠⁄©ŸÖ ÿ®ÿßÿ¥ŸÜÿØ',
                minimum: 10,
                maximum: 20,
              },
              cause: {
                type: 'string',
                description:
                  'ÿÆÿ∑ÿß€å ÿÆÿßÿµ €åÿß ÿßÿ¥ÿ™ÿ®ÿßŸá€å ⁄©Ÿá ÿ±ŸàÿßŸÜ ÿ¥ŸÜÿßÿ≥ ŸÖÿ±ÿ™⁄©ÿ® ÿ¥ÿØŸá Ÿà ŸÖŸÜÿ¨ÿ± ÿ®Ÿá ⁄©ÿ≥ÿ± ÿßŸÖÿ™€åÿßÿ≤ ÿ¥ÿØŸá ÿßÿ≥ÿ™',
              },
            },
            required: ['points', 'cause'],
          },
          description:
            'ŸÅŸáÿ±ÿ≥ÿ™€å ÿßÿ≤ ŸÖÿ≥ÿßÿ¶ŸÑ ÿπŸÖŸÑ⁄©ÿ±ÿØ€å ⁄©Ÿá ÿßŸÖÿ™€åÿßÿ≤ ⁄©ŸÑ€å ÿØÿ±ŸÖÿßŸÜ⁄Øÿ± ÿ±ÿß ⁄©ÿßŸáÿ¥ ŸÖ€å ÿØŸáÿØ. ÿßŸÖÿ™€åÿßÿ≤ ŸÜŸáÿß€å€å (psychotherapistEvaluationScore) ÿ®ÿß€åÿØ ÿ®Ÿá ÿµŸàÿ±ÿ™ €±€∞€∞ ŸÖŸÜŸáÿß€å ŸÖÿ¨ŸÖŸàÿπ ÿ™ŸÖÿßŸÖ ÿßŸÖÿ™€åÿßÿ≤ÿßÿ™ ⁄©ÿ≥ÿ± ÿ¥ÿØŸá ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ÿ¥ŸàÿØ.',
          minItems: 0,
          maxItems: 5,
        },
        psychotherapistEvaluationScorePositiveBehavior: {
          type: 'array',
          items: {
            type: 'string',
            description: 'ÿ±ŸÅÿ™ÿßÿ± ŸÖÿ´ÿ®ÿ™€å ⁄©Ÿá ÿ™Ÿàÿ≥ÿ∑ ÿ±ŸàÿßŸÜ ÿ¥ŸÜÿßÿ≥ ŸÜÿ¥ÿßŸÜ ÿØÿßÿØŸá ÿ¥ÿØŸá ÿßÿ≥ÿ™',
          },
          description:
            'ŸÅŸáÿ±ÿ≥ÿ™€å ÿßÿ≤ ÿ±ŸÅÿ™ÿßÿ±Ÿáÿß€å ŸÖÿ´ÿ®ÿ™€å ⁄©Ÿá ÿ±ŸàÿßŸÜ ÿ¥ŸÜÿßÿ≥ ÿØÿ± ÿ∑ŸàŸÑ ÿ¨ŸÑÿ≥Ÿá ŸÜÿ¥ÿßŸÜ ÿØÿßÿØŸá ÿßÿ≥ÿ™. ÿØŸÇ€åŸÇÿßŸã ÿ®ÿß€åÿØ ÿ¢ÿ±ÿß€åŸá ÿß€å ÿßÿ≤ ÿ±ÿ¥ÿ™Ÿá Ÿáÿß ÿ®ÿßÿ¥ÿØ',
          minItems: 0,
          maxItems: 5,
        },
        psychotherapistEvaluationScoreSuggestionsToImprove: {
          type: 'array',
          items: {
            type: 'string',
            description: 'Ÿæ€åÿ¥ŸÜŸáÿßÿØ€å ÿ®ÿ±ÿß€å ÿ®Ÿáÿ®ŸàÿØ ÿπŸÖŸÑ⁄©ÿ±ÿØ ÿ±ŸàÿßŸÜ ÿ¥ŸÜÿßÿ≥',
          },
          description:
            'ŸÅŸáÿ±ÿ≥ÿ™€å ÿßÿ≤ Ÿæ€åÿ¥ŸÜŸáÿßÿØÿßÿ™ ÿ®ÿ±ÿß€å ÿ®Ÿáÿ®ŸàÿØ ÿπŸÖŸÑ⁄©ÿ±ÿØ ÿ±ŸàÿßŸÜ ÿ¥ŸÜÿßÿ≥. ÿØŸÇ€åŸÇÿßŸã ÿ®ÿß€åÿØ ÿ¢ÿ±ÿß€åŸá ÿß€å ÿßÿ≤ ÿ±ÿ¥ÿ™Ÿá Ÿáÿß ÿ®ÿßÿ¥ÿØ',
          minItems: 3,
          maxItems: 5,
        },
      },
      required: [
        'psychotherapistEvaluation',
        'negativeScoresList',
        'psychotherapistEvaluationScorePositiveBehavior',
        'psychotherapistEvaluationScoreSuggestionsToImprove',
      ],
    }

    return await makeOpenRouterRequest(
      [
        { role: 'system', content: systemMessage },
        {
          role: 'user',
          content: `ŸÑÿ∑ŸÅÿß Ÿæ€åÿßŸÖ‚ÄåŸáÿß€å ÿ≤€åÿ± ÿ±ÿß ÿ™ÿ≠ŸÑ€åŸÑ ⁄©ŸÜ€åÿØ:\n${messages
            .map((m) => `${m.role}: ${m.content}`)
            .join('\n')}`,
        },
      ],
      schema,
      600, // Reduced from 1200 to 600 to prevent truncation
    )
  }

  const getBehavioralAnalysis = async (messages: any[]) => {
    const systemMessage =
      'ÿ¥ŸÖÿß €å⁄© ÿØÿ≥ÿ™€åÿßÿ± ÿ™ÿ≠ŸÑ€åŸÑ⁄Øÿ± ÿ¨ŸÑÿ≥ÿßÿ™ ÿ±ŸàÿßŸÜÿ¥ŸÜÿßÿ≥€å Ÿáÿ≥ÿ™€åÿØ. ŸÑÿ∑ŸÅÿß ÿßŸÑ⁄ØŸàŸáÿß€å ÿ±ŸÅÿ™ÿßÿ±€å ÿ®€åŸÖÿßÿ± Ÿà ÿ¥ŸàÿßŸáÿØ ÿ±ÿß ÿ™ÿ≠ŸÑ€åŸÑ ⁄©ŸÜ€åÿØ. ÿÆÿ±Ÿàÿ¨€å ÿ¥ŸÖÿß ÿ®ÿß€åÿØ ÿ®Ÿá ÿ¥⁄©ŸÑ JSON ÿ®ÿßÿ¥ÿØ. ÿß€åŸÜ json ÿ®ÿß€åÿØ ŸÖÿπÿ™ÿ®ÿ± ÿ®ÿßÿ¥ÿØ. ÿ™ŸÖÿßŸÖ Ÿæÿßÿ≥ÿÆ‚ÄåŸáÿß ÿ®ÿß€åÿØ ÿ®Ÿá ÿ≤ÿ®ÿßŸÜ ŸÅÿßÿ±ÿ≥€å ÿ®ÿßÿ¥ŸÜÿØ Ÿà ÿ™ŸÖÿßŸÖ ŸÖŸÇÿßÿØ€åÿ± ÿ±ÿ¥ÿ™Ÿá‚Äåÿß€å ÿ®ÿß€åÿØ ÿ®Ÿá ÿπŸÜŸàÿßŸÜ ŸÖÿ™ŸÜ ÿ®ÿßÿ¥ŸÜÿØ.'

    const schema = {
      type: 'object',
      properties: {
        behavioralAnalysisSummary: {
          type: 'string',
          description:
            'ÿ™ÿ≠ŸÑ€åŸÑ ÿßŸÑ⁄ØŸàŸáÿß€å ÿ±ŸÅÿ™ÿßÿ±€å ÿ®€åŸÖÿßÿ± Ÿà ÿ¥ŸàÿßŸáÿØ. ŸÇŸà€åÿßŸã ÿ®ÿß€åÿØ ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ÿ™ÿ≠ŸÑ€åŸÑ ÿ±ŸÅÿ™ÿßÿ±€å ÿ®ÿßÿ¥ÿØ. ÿß⁄Øÿ± ŸÖÿ∑ŸÖÿ¶ŸÜ ŸÜ€åÿ≥ÿ™€åÿØ ÿÆÿßŸÑ€å ÿ®⁄Øÿ∞ÿßÿ±€åÿØ',
        },
      },
      required: ['behavioralAnalysisSummary'],
    }

    return await makeOpenRouterRequest(
      [
        { role: 'system', content: systemMessage },
        {
          role: 'user',
          content: `ŸÑÿ∑ŸÅÿß Ÿæ€åÿßŸÖ‚ÄåŸáÿß€å ÿ≤€åÿ± ÿ±ÿß ÿ™ÿ≠ŸÑ€åŸÑ ⁄©ŸÜ€åÿØ:\n${messages
            .map((m) => `${m.role}: ${m.content}`)
            .join('\n')}`,
        },
      ],
      schema,
      400, // Reduced from 800 to 400 to prevent truncation
    )
  }

  const getEmotionalAnalysis = async (messages: any[]) => {
    const systemMessage =
      'ÿ¥ŸÖÿß €å⁄© ÿØÿ≥ÿ™€åÿßÿ± ÿ™ÿ≠ŸÑ€åŸÑ⁄Øÿ± ÿ¨ŸÑÿ≥ÿßÿ™ ÿ±ŸàÿßŸÜÿ¥ŸÜÿßÿ≥€å Ÿáÿ≥ÿ™€åÿØ. ŸÑÿ∑ŸÅÿß ÿ≠ÿßŸÑÿ™ Ÿáÿß Ÿà ÿßŸÑ⁄ØŸàŸáÿß€å ÿßÿ≠ÿ≥ÿßÿ≥€å ÿ®€åŸÖÿßÿ± ÿ±ÿß ÿ™ÿ≠ŸÑ€åŸÑ ⁄©ŸÜ€åÿØ. ÿÆÿ±Ÿàÿ¨€å ÿ¥ŸÖÿß ÿ®ÿß€åÿØ ÿ®Ÿá ÿ¥⁄©ŸÑ JSON ÿ®ÿßÿ¥ÿØ. ÿß€åŸÜ json ÿ®ÿß€åÿØ ŸÖÿπÿ™ÿ®ÿ± ÿ®ÿßÿ¥ÿØ. ÿ™ŸÖÿßŸÖ Ÿæÿßÿ≥ÿÆ‚ÄåŸáÿß ÿ®ÿß€åÿØ ÿ®Ÿá ÿ≤ÿ®ÿßŸÜ ŸÅÿßÿ±ÿ≥€å ÿ®ÿßÿ¥ŸÜÿØ Ÿà ÿ™ŸÖÿßŸÖ ŸÖŸÇÿßÿØ€åÿ± ÿ±ÿ¥ÿ™Ÿá‚Äåÿß€å ÿ®ÿß€åÿØ ÿ®Ÿá ÿπŸÜŸàÿßŸÜ ŸÖÿ™ŸÜ ÿ®ÿßÿ¥ŸÜÿØ.'

    const schema = {
      type: 'object',
      properties: {
        emotionalAnalysisSummary: {
          type: 'string',
          description:
            'ÿ™ÿ≠ŸÑ€åŸÑ ÿ≠ÿßŸÑÿ™ Ÿáÿß Ÿà ÿßŸÑ⁄ØŸàŸáÿß€å ÿßÿ≠ÿ≥ÿßÿ≥€å ÿ®€åŸÖÿßÿ±. ŸÇŸà€åÿßŸã ÿ®ÿß€åÿØ ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ÿ™ÿ≠ŸÑ€åŸÑ ÿßÿ≠ÿ≥ÿßÿ≥€å ÿ®ÿßÿ¥ÿØ. ÿß⁄Øÿ± ŸÖÿ∑ŸÖÿ¶ŸÜ ŸÜ€åÿ≥ÿ™€åÿØ ÿÆÿßŸÑ€å ÿ®⁄Øÿ∞ÿßÿ±€åÿØ',
        },
      },
      required: ['emotionalAnalysisSummary'],
    }

    return await makeOpenRouterRequest(
      [
        { role: 'system', content: systemMessage },
        {
          role: 'user',
          content: `ŸÑÿ∑ŸÅÿß Ÿæ€åÿßŸÖ‚ÄåŸáÿß€å ÿ≤€åÿ± ÿ±ÿß ÿ™ÿ≠ŸÑ€åŸÑ ⁄©ŸÜ€åÿØ:\n${messages
            .map((m) => `${m.role}: ${m.content}`)
            .join('\n')}`,
        },
      ],
      schema,
      800,
    )
  }

  const getThoughtsAndConcerns = async (messages: any[]) => {
    const systemMessage =
      'ÿ¥ŸÖÿß €å⁄© ÿØÿ≥ÿ™€åÿßÿ± ÿ™ÿ≠ŸÑ€åŸÑ⁄Øÿ± ÿ¨ŸÑÿ≥ÿßÿ™ ÿ±ŸàÿßŸÜÿ¥ŸÜÿßÿ≥€å Ÿáÿ≥ÿ™€åÿØ. ŸÑÿ∑ŸÅÿß ÿßŸÅ⁄©ÿßÿ± Ÿà ŸÜ⁄Øÿ±ÿßŸÜ€å Ÿáÿß€å ÿßÿµŸÑ€å ÿ®€åŸÖÿßÿ± ÿ±ÿß ÿÆŸÑÿßÿµŸá ⁄©ŸÜ€åÿØ. ÿÆÿ±Ÿàÿ¨€å ÿ¥ŸÖÿß ÿ®ÿß€åÿØ ÿ®Ÿá ÿ¥⁄©ŸÑ JSON ÿ®ÿßÿ¥ÿØ. ÿß€åŸÜ json ÿ®ÿß€åÿØ ŸÖÿπÿ™ÿ®ÿ± ÿ®ÿßÿ¥ÿØ.'

    const schema = {
      type: 'object',
      properties: {
        thoughtsAndConcernsSummary: {
          type: 'string',
          description:
            'ÿÆŸÑÿßÿµŸá ÿß€å ÿßÿ≤ ÿßŸÅ⁄©ÿßÿ± Ÿà ŸÜ⁄Øÿ±ÿßŸÜ€å Ÿáÿß€å ÿßÿµŸÑ€å ÿ®€åŸÖÿßÿ±. ÿß⁄Øÿ± ŸÖÿ∑ŸÖÿ¶ŸÜ ŸÜ€åÿ≥ÿ™€åÿØ ÿÆÿßŸÑ€å ÿ®⁄Øÿ∞ÿßÿ±€åÿØ',
        },
      },
      required: ['thoughtsAndConcernsSummary'],
    }

    return await makeOpenRouterRequest(
      [
        { role: 'system', content: systemMessage },
        {
          role: 'user',
          content: `ŸÑÿ∑ŸÅÿß Ÿæ€åÿßŸÖ‚ÄåŸáÿß€å ÿ≤€åÿ± ÿ±ÿß ÿ™ÿ≠ŸÑ€åŸÑ ⁄©ŸÜ€åÿØ:\n${messages
            .map((m) => `${m.role}: ${m.content}`)
            .join('\n')}`,
        },
      ],
      schema,
      800,
    )
  }

  const getPsychoAnalysis = async (messages: any[]) => {
    const systemMessage =
      'ÿ¥ŸÖÿß €å⁄© ÿØÿ≥ÿ™€åÿßÿ± ÿ™ÿ≠ŸÑ€åŸÑ⁄Øÿ± ÿ¨ŸÑÿ≥ÿßÿ™ ÿ±ŸàÿßŸÜÿ¥ŸÜÿßÿ≥€å Ÿáÿ≥ÿ™€åÿØ. ŸÑÿ∑ŸÅÿß ÿ™ŸÅÿ≥€åÿ± ÿ±ŸàÿßŸÜ⁄©ÿßŸà€å ÿ¨ŸÑÿ≥Ÿá ÿ±ÿß ÿßÿ±ÿßÿ¶Ÿá ÿØŸá€åÿØ. ÿÆÿ±Ÿàÿ¨€å ÿ¥ŸÖÿß ÿ®ÿß€åÿØ ÿ®Ÿá ÿ¥⁄©ŸÑ JSON ÿ®ÿßÿ¥ÿØ. ÿß€åŸÜ json ÿ®ÿß€åÿØ ŸÖÿπÿ™ÿ®ÿ± ÿ®ÿßÿ¥ÿØ.'

    const schema = {
      type: 'object',
      properties: {
        psychoAnalysis: {
          type: 'string',
          description:
            'ÿ™ŸÅÿ≥€åÿ± ÿ±ŸàÿßŸÜ⁄©ÿßŸà€å ÿ¨ŸÑÿ≥Ÿá. ÿ®ÿß€åÿØ ŸÖŸÅÿµŸÑ Ÿà ÿßÿ≤ ÿØ€åÿØ⁄ØÿßŸá ÿ±ŸàÿßŸÜ⁄©ÿßŸà€å ÿ®ÿßÿ¥ÿØ. ÿßŸÅ⁄©ÿßÿ±ÿå ÿßÿ≠ÿ≥ÿßÿ≥ÿßÿ™ Ÿà ÿ™ÿ¨ÿ±ÿ®€åÿßÿ™ ŸÜÿßÿÆŸàÿØÿ¢⁄ØÿßŸá ŸáŸÖÿ±ÿßŸá ÿ®ÿß ŸÖŸÜÿå ÿÆŸàÿØ Ÿà ŸÅÿ±ÿßÿÆŸàÿØ. ÿß€åŸÜ ÿ™ÿ≠ŸÑ€åŸÑ ÿ®ÿß€åÿØ ÿ®Ÿá ÿ≤ÿ®ÿßŸÜ ŸÅÿßÿ±ÿ≥€å ÿ®ÿßÿ¥ÿØ.',
        },
        possibleDeeperGoalsOfPatient: {
          type: 'string',
          description:
            'ÿ™ÿ≠ŸÑ€åŸÑ ÿßŸáÿØÿßŸÅ €åÿß ÿßŸÜ⁄Ø€åÿ≤Ÿá Ÿáÿß€å ÿπŸÖ€åŸÇ ÿ™ÿ± Ÿà ŸæŸÜŸáÿßŸÜ ÿ®€åŸÖÿßÿ± ⁄©Ÿá ŸÖŸÖ⁄©ŸÜ ÿßÿ≥ÿ™ ÿ®Ÿá ÿ∑Ÿàÿ± ÿµÿ±€åÿ≠ ÿ®€åÿßŸÜ ŸÜÿ¥ÿØŸá ÿ®ÿßÿ¥ÿØÿå ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ŸÖŸàÿ∂Ÿàÿπÿßÿ™ ŸÖÿ∑ÿ±ÿ≠ ÿ¥ÿØŸá ÿØÿ± ÿ¨ŸÑÿ≥Ÿá. ÿß€åŸÜ ÿ™Ÿàÿ∂€åÿ≠ ÿ®ÿß€åÿØ ÿ®Ÿá ÿ≤ÿ®ÿßŸÜ ŸÅÿßÿ±ÿ≥€å ÿ®ÿßÿ¥ÿØ.',
        },
      },
      required: ['psychoAnalysis', 'possibleDeeperGoalsOfPatient'],
    }

    return await makeOpenRouterRequest(
      [
        { role: 'system', content: systemMessage },
        {
          role: 'user',
          content: `ŸÑÿ∑ŸÅÿß Ÿæ€åÿßŸÖ‚ÄåŸáÿß€å ÿ≤€åÿ± ÿ±ÿß ÿ™ÿ≠ŸÑ€åŸÑ ⁄©ŸÜ€åÿØ:\n${messages
            .map((m) => `${m.role}: ${m.content}`)
            .join('\n')}`,
        },
      ],
      schema,
      1200,
    )
  }

  const getDefenseMechanisms = async (messages: any[]) => {
    const systemMessage =
      'ÿ¥ŸÖÿß €å⁄© ÿØÿ≥ÿ™€åÿßÿ± ÿ™ÿ≠ŸÑ€åŸÑ⁄Øÿ± ÿ¨ŸÑÿ≥ÿßÿ™ ÿ±ŸàÿßŸÜÿ¥ŸÜÿßÿ≥€å Ÿáÿ≥ÿ™€åÿØ. ŸÑÿ∑ŸÅÿß ŸÖ⁄©ÿßŸÜ€åÿ≥ŸÖ Ÿáÿß€å ÿØŸÅÿßÿπ€å ÿ¥ŸÜÿßÿ≥ÿß€å€å ÿ¥ÿØŸá ÿØÿ± ÿ∑ŸàŸÑ ÿ¨ŸÑÿ≥Ÿá ÿ±ÿß ÿ™ÿ≠ŸÑ€åŸÑ ⁄©ŸÜ€åÿØ. ÿÆÿ±Ÿàÿ¨€å ÿ¥ŸÖÿß ÿ®ÿß€åÿØ ÿ®Ÿá ÿ¥⁄©ŸÑ JSON ÿ®ÿßÿ¥ÿØ. ÿß€åŸÜ json ÿ®ÿß€åÿØ ŸÖÿπÿ™ÿ®ÿ± ÿ®ÿßÿ¥ÿØ.'

    const schema = {
      type: 'object',
      properties: {
        detectedDefenceMechanisms: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              name: {
                type: 'string',
                enum: [
                  'ÿßŸÜ⁄©ÿßÿ±', // denial
                  'ŸÅÿ±ÿßŸÅ⁄©ŸÜ€å', // projection
                  'ÿπŸÇŸÑÿßŸÜ€å ÿ≥ÿßÿ≤€å', // rationalization
                  'Ÿæÿ≥ÿ±ŸÅÿ™', // regression
                  'ÿ¨ÿßÿ®ÿ¨ÿß€å€å', // displacement
                  'ÿ≥ÿ±⁄©Ÿàÿ®', // repression
                  'Ÿàÿß⁄©ŸÜÿ¥ Ÿàÿßÿ±ŸàŸÜŸá', // reaction formation
                  'ŸàÿßŸÑÿß€åÿ¥', // sublimation
                  'ÿπŸÇŸÑÿßŸÜ€å ⁄©ÿ±ÿØŸÜ', // intellectualization
                  'ÿ¨ÿØÿßÿ≥ÿßÿ≤€å', // isolation
                  'ÿ®ÿßÿ∑ŸÑ ÿ≥ÿßÿ≤€å', // undoing
                  'ŸáŸÖÿßŸÜŸÜÿØÿ≥ÿßÿ≤€å', // identification
                  'ŸÅÿ±ŸàŸÜÿ¥ÿßŸÜ€å', // suppression
                  'ÿ¨ÿØÿßÿ≥ÿßÿ≤€å ÿ∞ŸáŸÜ€å', // compartmentalization
                  'ŸÖŸÜŸÅÿπŸÑ Ÿæÿ±ÿÆÿßÿ¥⁄Øÿ±', // passive aggressive
                  'ÿπŸÖŸÑ ⁄Øÿ±ÿß€å€å', // acting out
                  'ÿÆ€åÿßŸÑ Ÿæÿ±ÿØÿßÿ≤€å', // fantasy
                  'ÿ¥ŸàÿÆ€å', // humor
                  '⁄Øÿ≥ÿ≥ÿ™⁄Ø€å', // dissociation
                  'ÿßÿ¨ÿ™ŸÜÿßÿ®', // avoidance
                  'ŸÇÿ±ÿ®ÿßŸÜ€å ⁄©ÿ±ÿØŸÜ', // scapegoating
                  'ÿ®ÿØŸàŸÜ ÿØÿßÿØŸá', // no_data
                ],
              },
              confidence: {
                type: 'string',
                enum: ['very_low', 'low', 'high', 'very_high'],
              },
              evidence: {
                type: 'string',
                description:
                  'ÿ®ÿÆÿ¥€å ÿßÿ≤ Ÿæ€åÿßŸÖ ÿØŸÇ€åŸÇ ⁄©ÿßÿ±ÿ®ÿ± ⁄©Ÿá ÿ≠ÿßŸà€å ÿ¥ŸàÿßŸáÿØ ÿß€åŸÜ ŸÖ⁄©ÿßŸÜ€åÿ≥ŸÖ ÿØŸÅÿßÿπ€å ÿßÿ≥ÿ™. ÿ®ÿß€åÿØ Ÿæ€åÿßŸÖ ÿØŸÇ€åŸÇ ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿßÿ¥ÿØÿå ŸÜŸá ⁄Ü€åÿ≤ ÿØ€å⁄Øÿ±€å. ÿ®Ÿá ÿπŸÜŸàÿßŸÜ ÿ¥ŸàÿßŸáÿØ€å ÿ®ÿ±ÿß€å ÿß€åŸÜ ŸÖ⁄©ÿßŸÜ€åÿ≥ŸÖ ÿØŸÅÿßÿπ€å',
              },
            },
            required: ['name', 'confidence', 'evidence'],
          },
          description:
            'ŸÅŸáÿ±ÿ≥ÿ™€å ÿßÿ≤ ŸÖ⁄©ÿßŸÜ€åÿ≥ŸÖ Ÿáÿß€å ÿØŸÅÿßÿπ€å ÿ¥ŸÜÿßÿ≥ÿß€å€å ÿ¥ÿØŸá ÿØÿ± ÿ∑ŸàŸÑ ÿ¨ŸÑÿ≥Ÿá ÿ®ÿß ÿ≥ÿ∑Ÿàÿ≠ ÿßÿ∑ŸÖ€åŸÜÿßŸÜ Ÿà ÿ¥ŸàÿßŸáÿØ Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ. ÿß⁄Øÿ± ⁄Ü€åÿ≤€å ÿ¥ŸÜÿßÿ≥ÿß€å€å ŸÜÿ¥ÿØ €åÿß ŸÖÿ∑ŸÖÿ¶ŸÜ ŸÜ€åÿ≥ÿ™€åÿØ ÿßÿ≤ name: no_data ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ.',
        },
      },
      required: ['detectedDefenceMechanisms'],
    }

    return await makeOpenRouterRequest(
      [
        { role: 'system', content: systemMessage },
        {
          role: 'user',
          content: `ŸÑÿ∑ŸÅÿß Ÿæ€åÿßŸÖ‚ÄåŸáÿß€å ÿ≤€åÿ± ÿ±ÿß ÿ™ÿ≠ŸÑ€åŸÑ ⁄©ŸÜ€åÿØ:\n${messages
            .map((m) => `${m.role}: ${m.content}`)
            .join('\n')}`,
        },
      ],
      schema,
      1000,
    )
  }

  const getSchemas = async (messages: any[]) => {
    const systemMessage =
      'ÿ¥ŸÖÿß €å⁄© ÿØÿ≥ÿ™€åÿßÿ± ÿ™ÿ≠ŸÑ€åŸÑ⁄Øÿ± ÿ¨ŸÑÿ≥ÿßÿ™ ÿ±ŸàÿßŸÜÿ¥ŸÜÿßÿ≥€å Ÿáÿ≥ÿ™€åÿØ. ŸÑÿ∑ŸÅÿß ÿßŸÑ⁄ØŸàŸáÿß€å ÿ¥ŸÜÿßÿ≥ÿß€å€å ÿ¥ÿØŸá ÿØÿ± ÿ∑ŸàŸÑ ÿ¨ŸÑÿ≥Ÿá ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ŸÜÿ∏ÿ±€åŸá ÿßŸÑ⁄ØŸàŸáÿß€å €åÿßŸÜ⁄Ø ÿ±ÿß ÿ™ÿ≠ŸÑ€åŸÑ ⁄©ŸÜ€åÿØ. ÿÆÿ±Ÿàÿ¨€å ÿ¥ŸÖÿß ÿ®ÿß€åÿØ ÿ®Ÿá ÿ¥⁄©ŸÑ JSON ÿ®ÿßÿ¥ÿØ. ÿß€åŸÜ json ÿ®ÿß€åÿØ ŸÖÿπÿ™ÿ®ÿ± ÿ®ÿßÿ¥ÿØ.'

    const schema = {
      type: 'object',
      properties: {
        detectedSchemas: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              name: {
                type: 'string',
                enum: [
                  'ÿ±Ÿáÿßÿ¥ÿØ⁄Ø€å', // abandonment
                  'ÿ®€å ÿßÿπÿ™ŸÖÿßÿØ€å Ÿà ÿ®ÿØÿ±ŸÅÿ™ÿßÿ±€å', // mistrust abuse
                  'ŸÖÿ≠ÿ±ŸàŸÖ€åÿ™ Ÿá€åÿ¨ÿßŸÜ€å', // emotional deprivation
                  'ŸÜŸÇÿµ', // defectiveness
                  'ÿßŸÜÿ≤Ÿàÿß€å ÿßÿ¨ÿ™ŸÖÿßÿπ€å', // social isolation
                  'Ÿàÿßÿ®ÿ≥ÿ™⁄Ø€å', // dependence
                  'ÿ¢ÿ≥€åÿ® Ÿæÿ∞€åÿ±€å', // vulnerability
                  '⁄Øÿ±ŸÅÿ™ÿßÿ±€å', // enmeshment
                  'ÿ¥⁄©ÿ≥ÿ™', // failure
                  'ÿßÿ≥ÿ™ÿ≠ŸÇÿßŸÇ', // entitlement
                  'ÿÆŸà€åÿ¥ÿ™ŸÜ ÿØÿßÿ±€å ŸÜÿß⁄©ÿßŸÅ€å', // insufficient self control
                  'ÿßÿ∑ÿßÿπÿ™', // subjugation
                  'ÿß€åÿ´ÿßÿ±', // self sacrifice
                  'ÿ™ÿß€å€åÿØ ÿ¨Ÿà€å€å', // approval seeking
                  'ŸÖŸÜŸÅ€å ⁄Øÿ±ÿß€å€å', // negativity
                  'ÿ®ÿßÿ≤ÿØÿßÿ±€å Ÿá€åÿ¨ÿßŸÜ€å', // emotional inhibition
                  'ŸÖÿπ€åÿßÿ±Ÿáÿß€å ÿ≥ÿ±ÿ≥ÿÆÿ™ÿßŸÜŸá', // unrelenting standards
                  'ÿ™ŸÜÿ®€åŸá', // punitiveness
                  'ÿ®ÿØŸàŸÜ ÿØÿßÿØŸá', // no data
                ],
              },
              confidence: {
                type: 'string',
                enum: ['very_low', 'low', 'high', 'very_high'],
              },
              evidence: {
                type: 'string',
                description:
                  'ÿ¥ŸàÿßŸáÿØ Ÿà ŸÜŸÖŸàŸÜŸá Ÿáÿß€å€å ⁄©Ÿá ÿ™Ÿàÿ≥ÿ∑ ÿ®€åŸÖÿßÿ± ÿ∞⁄©ÿ± ÿ¥ÿØŸá Ÿà ÿß€åŸÜ ÿßŸÑ⁄ØŸà ÿ±ÿß Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å ŸÖ€å ⁄©ŸÜÿØ',
              },
            },
            required: ['name', 'confidence', 'evidence'],
          },
          description:
            'ŸÅŸáÿ±ÿ≥ÿ™€å ÿßÿ≤ ÿßŸÑ⁄ØŸàŸáÿß€å ÿ¥ŸÜÿßÿ≥ÿß€å€å ÿ¥ÿØŸá ÿØÿ± ÿ∑ŸàŸÑ ÿ¨ŸÑÿ≥Ÿá ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ŸÜÿ∏ÿ±€åŸá ÿßŸÑ⁄ØŸàŸáÿß€å €åÿßŸÜ⁄Ø ÿ®ÿß ÿ≥ÿ∑Ÿàÿ≠ ÿßÿ∑ŸÖ€åŸÜÿßŸÜ Ÿà ÿ¥ŸàÿßŸáÿØ Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ. ÿß⁄Øÿ± ⁄Ü€åÿ≤€å ÿ¥ŸÜÿßÿ≥ÿß€å€å ŸÜÿ¥ÿØ €åÿß ŸÖÿ∑ŸÖÿ¶ŸÜ ŸÜ€åÿ≥ÿ™€åÿØ ÿßÿ≤ name: no_data ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ.',
        },
      },
      required: ['detectedSchemas'],
    }

    return await makeOpenRouterRequest(
      [
        { role: 'system', content: systemMessage },
        {
          role: 'user',
          content: `ŸÑÿ∑ŸÅÿß Ÿæ€åÿßŸÖ‚ÄåŸáÿß€å ÿ≤€åÿ± ÿ±ÿß ÿ™ÿ≠ŸÑ€åŸÑ ⁄©ŸÜ€åÿØ:\n${messages
            .map((m) => `${m.role}: ${m.content}`)
            .join('\n')}`,
        },
      ],
      schema,
      1000,
    )
  }

  const getDemographicData = async (messages: any[]) => {
    const systemMessage =
      'ÿ¥ŸÖÿß €å⁄© ÿØÿ≥ÿ™€åÿßÿ± ÿ™ÿ≠ŸÑ€åŸÑ⁄Øÿ± ÿ¨ŸÑÿ≥ÿßÿ™ ÿ±ŸàÿßŸÜÿ¥ŸÜÿßÿ≥€å Ÿáÿ≥ÿ™€åÿØ. ŸÑÿ∑ŸÅÿß ÿßÿ∑ŸÑÿßÿπÿßÿ™ ÿØŸÖŸà⁄Øÿ±ÿßŸÅ€å⁄© ÿ®€åŸÖÿßÿ± ÿ±ÿß ÿßÿ≤ ÿ¨ŸÑÿ≥Ÿá ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ⁄©ŸÜ€åÿØ.ÿÆÿ±Ÿàÿ¨€å ÿ¥ŸÖÿß ÿ®ÿß€åÿØ ÿ®Ÿá ÿ¥⁄©ŸÑ JSON ÿ®ÿßÿ¥ÿØ. ÿß€åŸÜ json ÿ®ÿß€åÿØ ŸÖÿπÿ™ÿ®ÿ± ÿ®ÿßÿ¥ÿØ.'

    const schema = {
      type: 'object',
      properties: {
        demographicData: {
          type: 'object',
          properties: {
            firstName: {
              type: 'string',
              description:
                'ŸÜÿßŸÖ ⁄©Ÿà⁄Ü⁄© ÿ®€åŸÖÿßÿ±ÿå ÿß⁄Øÿ± ÿ∞⁄©ÿ± ŸÜÿ¥ÿØŸá ÿ®ÿßÿ¥ÿØ ŸÖ€å ÿ™ŸàÿßŸÜÿØ null ÿ®ÿßÿ¥ÿØ',
              nullable: true,
            },
            lastName: {
              type: 'string',
              description:
                'ŸÜÿßŸÖ ÿÆÿßŸÜŸàÿßÿØ⁄Ø€å ÿ®€åŸÖÿßÿ±ÿå ÿß⁄Øÿ± ÿ∞⁄©ÿ± ŸÜÿ¥ÿØŸá ÿ®ÿßÿ¥ÿØ ŸÖ€å ÿ™ŸàÿßŸÜÿØ null ÿ®ÿßÿ¥ÿØ',
              nullable: true,
            },
            age: {
              type: 'number',
              description: 'ÿ≥ŸÜ ÿ®€åŸÖÿßÿ±ÿå ÿß⁄Øÿ± ÿ∞⁄©ÿ± ŸÜÿ¥ÿØŸá ÿ®ÿßÿ¥ÿØ ŸÖ€å ÿ™ŸàÿßŸÜÿØ null ÿ®ÿßÿ¥ÿØ',
              nullable: true,
            },
            gender: {
              type: 'string',
              enum: ['male', 'female', 'other', null],
              description:
                'ÿ¨ŸÜÿ≥€åÿ™ ÿ®€åŸÖÿßÿ±ÿå ÿß⁄Øÿ± ŸÜÿßŸÖ ÿßÿ±ÿßÿ¶Ÿá ÿ¥ÿØŸá ÿ®ÿßÿ¥ÿØ ÿßÿ≤ ÿ±Ÿà€å ÿ¢ŸÜ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ⁄©ŸÜ€åÿØ. ÿß⁄Øÿ± ŸÖÿ∑ŸÖÿ¶ŸÜ ŸÜ€åÿ≥ÿ™€åÿØ ÿßÿ≤ null ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ.',
              nullable: true,
            },
            education: {
              type: 'string',
              enum: [
                'under diploma',
                'diploma',
                'bachelor',
                'master',
                'phd',
                'other',
              ],
              description:
                'ÿ≥ÿ∑ÿ≠ ÿ™ÿ≠ÿµ€åŸÑÿßÿ™ ÿ®€åŸÖÿßÿ±ÿå ÿß⁄Øÿ± ÿ∞⁄©ÿ± ŸÜÿ¥ÿØŸá ÿ®ÿßÿ¥ÿØ ŸÖ€å ÿ™ŸàÿßŸÜÿØ null ÿ®ÿßÿ¥ÿØ',
              nullable: true,
            },
            occupation: {
              type: 'string',
              enum: [
                'student',
                'employed',
                'self-employed',
                'unemployed',
                'retired',
                'householder',
                'other',
              ],
              description: 'ÿ¥ÿ∫ŸÑ ÿ®€åŸÖÿßÿ±ÿå ÿß⁄Øÿ± ÿ∞⁄©ÿ± ŸÜÿ¥ÿØŸá ÿ®ÿßÿ¥ÿØ ŸÖ€å ÿ™ŸàÿßŸÜÿØ null ÿ®ÿßÿ¥ÿØ',
              nullable: true,
            },
            maritalStatus: {
              type: 'string',
              enum: ['single', 'married', 'divorced', 'widowed', null],
              description:
                'Ÿàÿ∂ÿπ€åÿ™ ÿ™ÿßŸáŸÑ ÿ®€åŸÖÿßÿ±ÿå ÿß⁄Øÿ± ÿ∞⁄©ÿ± ŸÜÿ¥ÿØŸá ÿ®ÿßÿ¥ÿØ ŸÖ€å ÿ™ŸàÿßŸÜÿØ null ÿ®ÿßÿ¥ÿØ',
              nullable: true,
            },
          },
          description:
            'ÿßÿ∑ŸÑÿßÿπÿßÿ™ ÿØŸÖŸà⁄Øÿ±ÿßŸÅ€å⁄© ÿØÿ±ÿ®ÿßÿ±Ÿá ÿ®€åŸÖÿßÿ± ⁄©Ÿá ÿßÿ≤ ÿ¨ŸÑÿ≥Ÿá ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿ¥ÿØŸá ÿßÿ≥ÿ™',
        },
      },
      required: ['demographicData'],
    }

    return await makeOpenRouterRequest(
      [
        { role: 'system', content: systemMessage },
        {
          role: 'user',
          content: `ŸÑÿ∑ŸÅÿß Ÿæ€åÿßŸÖ‚ÄåŸáÿß€å ÿ≤€åÿ± ÿ±ÿß ÿ™ÿ≠ŸÑ€åŸÑ ⁄©ŸÜ€åÿØ:\n${messages
            .map((m) => `${m.role}: ${m.content}`)
            .join('\n')}`,
        },
      ],
      schema,
      800,
    )
  }

  const getNextSteps = async (messages: any[]) => {
    const systemMessage =
      'ÿ¥ŸÖÿß €å⁄© ÿØÿ≥ÿ™€åÿßÿ± ÿ™ÿ≠ŸÑ€åŸÑ⁄Øÿ± ÿ¨ŸÑÿ≥ÿßÿ™ ÿ±ŸàÿßŸÜÿ¥ŸÜÿßÿ≥€å Ÿáÿ≥ÿ™€åÿØ. ŸÑÿ∑ŸÅÿß ŸÖÿ±ÿßÿ≠ŸÑ Ÿæ€åÿ¥ŸÜŸáÿßÿØ€å ÿ®ÿπÿØ€å ÿ®ÿ±ÿß€å ÿØÿ±ŸÖÿßŸÜ⁄Øÿ± ÿ±ÿß ÿßÿ±ÿßÿ¶Ÿá ÿØŸá€åÿØ. ÿÆÿ±Ÿàÿ¨€å ÿ¥ŸÖÿß ÿ®ÿß€åÿØ ÿ®Ÿá ÿ¥⁄©ŸÑ JSON ÿ®ÿßÿ¥ÿØ. ÿß€åŸÜ json ÿ®ÿß€åÿØ ŸÖÿπÿ™ÿ®ÿ± ÿ®ÿßÿ¥ÿØ.'

    const schema = {
      type: 'object',
      properties: {
        suggestedNextStepsForTherapistForNextSession: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              title: {
                type: 'string',
                description: 'ÿπŸÜŸàÿßŸÜ Ÿæ€åÿ¥ŸÜŸáÿßÿØ ŸÖÿ±ÿ≠ŸÑŸá ÿ®ÿπÿØ€å ÿ®ÿ±ÿß€å ÿØÿ±ŸÖÿßŸÜ⁄Øÿ±',
              },
              description: {
                type: 'string',
                description: 'ÿ™Ÿàÿ∂€åÿ≠ ŸÖŸÅÿµŸÑ Ÿæ€åÿ¥ŸÜŸáÿßÿØ ŸÖÿ±ÿ≠ŸÑŸá ÿ®ÿπÿØ€å',
              },
            },
            required: ['title', 'description'],
          },
          description:
            'ŸÅŸáÿ±ÿ≥ÿ™€å ÿßÿ≤ ŸÖÿ±ÿßÿ≠ŸÑ Ÿæ€åÿ¥ŸÜŸáÿßÿØ€å ÿ®ÿπÿØ€å ÿ®ÿ±ÿß€å ÿØÿ±ŸÖÿßŸÜ⁄Øÿ± ⁄©Ÿá ÿ®ÿß€åÿØ ÿØÿ± ÿ¨ŸÑÿ≥Ÿá ÿ®ÿπÿØ€å ŸÖÿØŸÜÿ∏ÿ± ŸÇÿ±ÿßÿ± ⁄Ø€åÿ±ÿØ. ÿ®ÿß€åÿØ ŸÖŸÜÿ≠ÿµÿ± ÿ®Ÿá ŸÅÿ±ÿØ Ÿà ÿ®ÿØŸàŸÜ ÿ™⁄©ÿ±ÿßÿ± ÿ®ÿßÿ¥ÿØ',
          minItems: 3,
          maxItems: 5,
        },
      },
      required: ['suggestedNextStepsForTherapistForNextSession'],
    }

    return await makeOpenRouterRequest(
      [
        { role: 'system', content: systemMessage },
        {
          role: 'user',
          content: `ŸÑÿ∑ŸÅÿß Ÿæ€åÿßŸÖ‚ÄåŸáÿß€å ÿ≤€åÿ± ÿ±ÿß ÿ™ÿ≠ŸÑ€åŸÑ ⁄©ŸÜ€åÿØ:\n${messages
            .map((m) => `${m.role}: ${m.content}`)
            .join('\n')}`,
        },
      ],
      schema,
      1000,
    )
  }

  const getRiskFactors = async (messages: any[]) => {
    const systemMessage =
      'ÿ¥ŸÖÿß €å⁄© ÿØÿ≥ÿ™€åÿßÿ± ÿ™ÿ≠ŸÑ€åŸÑ⁄Øÿ± ÿ¨ŸÑÿ≥ÿßÿ™ ÿ±ŸàÿßŸÜÿ¥ŸÜÿßÿ≥€å Ÿáÿ≥ÿ™€åÿØ. ŸÑÿ∑ŸÅÿß ÿπŸàÿßŸÖŸÑ ÿ±€åÿ≥⁄© ÿ¥ŸÜÿßÿ≥ÿß€å€å ÿ¥ÿØŸá ÿØÿ± ÿ∑ŸàŸÑ ÿ¨ŸÑÿ≥Ÿá ÿ±ÿß ÿ™ÿ≠ŸÑ€åŸÑ ⁄©ŸÜ€åÿØ. ÿÆÿ±Ÿàÿ¨€å ÿ¥ŸÖÿß ÿ®ÿß€åÿØ ÿ®Ÿá ÿ¥⁄©ŸÑ JSON ÿ®ÿßÿ¥ÿØ. ÿß€åŸÜ json ÿ®ÿß€åÿØ ŸÖÿπÿ™ÿ®ÿ± ÿ®ÿßÿ¥ÿØ.'

    const schema = {
      type: 'object',
      properties: {
        possibleRiskFactorsExtracted: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              title: {
                type: 'string',
                description:
                  'ÿπŸÜŸàÿßŸÜ ÿπÿßŸÖŸÑ ÿ±€åÿ≥⁄© ÿ¥ŸÜÿßÿ≥ÿß€å€å ÿ¥ÿØŸá ⁄©Ÿá ŸÜ€åÿßÿ≤ ÿ®Ÿá ÿ™Ÿàÿ¨Ÿá ÿ®€åÿ¥ÿ™ÿ± ÿØÿßÿ±ÿØ',
              },
              description: {
                type: 'string',
                description:
                  'ÿ™Ÿàÿ∂€åÿ≠ ŸÖŸÅÿµŸÑ ÿπÿßŸÖŸÑ ÿ±€åÿ≥⁄© ÿ¥ÿßŸÖŸÑ ÿßŸÅ⁄©ÿßÿ±ÿå ÿ±ŸÅÿ™ÿßÿ±Ÿáÿß €åÿß ÿ®ÿßŸàÿ±Ÿáÿß€å ŸÜ⁄Øÿ±ÿßŸÜ ⁄©ŸÜŸÜÿØŸá ÿ®€åŸÖÿßÿ± ⁄©Ÿá ŸÖŸÖ⁄©ŸÜ ÿßÿ≥ÿ™ ŸÜÿ¥ÿßŸÜ ÿßÿ≤ ÿ¢ÿ≥€åÿ® ÿ®Ÿá ÿÆŸàÿØ €åÿß ÿØ€å⁄Øÿ±ÿßŸÜ ÿØÿßÿ¥ÿ™Ÿá ÿ®ÿßÿ¥ÿØ Ÿà ŸÜ€åÿßÿ≤ ÿ®Ÿá ŸÖÿØÿßÿÆŸÑŸá ÿ≠ÿ±ŸÅŸá ÿß€å ÿ®€åÿ¥ÿ™ÿ± ÿØÿßÿ±ÿØ',
              },
            },
            required: ['title', 'description'],
          },
          description:
            'ŸÅŸáÿ±ÿ≥ÿ™€å ÿßÿ≤ ÿπŸàÿßŸÖŸÑ ÿ±€åÿ≥⁄© ÿ¥ŸÜÿßÿ≥ÿß€å€å ÿ¥ÿØŸá ÿØÿ± ÿ∑ŸàŸÑ ÿ¨ŸÑÿ≥Ÿá ŸÖÿ±ÿ™ÿ®ÿ∑ ÿ®ÿß ÿßŸÅ⁄©ÿßÿ±ÿå ÿ±ŸÅÿ™ÿßÿ±Ÿáÿß €åÿß ÿ®ÿßŸàÿ±Ÿáÿß€å ÿ®€åŸÖÿßÿ± ⁄©Ÿá ŸÖŸÖ⁄©ŸÜ ÿßÿ≥ÿ™ ŸÜ€åÿßÿ≤ ÿ®Ÿá ÿ™Ÿàÿ¨Ÿá €åÿß ŸÖÿØÿßÿÆŸÑŸá ÿ≠ÿ±ŸÅŸá ÿß€å ÿ®€åÿ¥ÿ™ÿ± ÿØÿßÿ¥ÿ™Ÿá ÿ®ÿßÿ¥ÿØ. ÿ®ÿß€åÿØ ŸÖŸÜÿ≠ÿµÿ± ÿ®Ÿá ŸÅÿ±ÿØ Ÿà ÿ®ÿØŸàŸÜ ÿ™⁄©ÿ±ÿßÿ± ÿ®ÿßÿ¥ÿØ',
          minItems: 1,
          maxItems: 5,
        },
      },
      required: ['possibleRiskFactorsExtracted'],
    }

    return await makeOpenRouterRequest(
      [
        { role: 'system', content: systemMessage },
        {
          role: 'user',
          content: `ŸÑÿ∑ŸÅÿß Ÿæ€åÿßŸÖ‚ÄåŸáÿß€å ÿ≤€åÿ± ÿ±ÿß ÿ™ÿ≠ŸÑ€åŸÑ ⁄©ŸÜ€åÿØ:\n${messages
            .map((m) => `${m.role}: ${m.content}`)
            .join('\n')}`,
        },
      ],
      schema,
      1000,
    )
  }

  const generateAnalysis = async ({
    sessionId,
    messages,
  }: {
    sessionId: string
    messages: any[]
  }) => {
    processing.value = true
    error.value = null

    try {
      console.log(
        'üîç Starting session analysis generation for session:',
        sessionId,
      )
      console.log('üì® Number of messages to analyze:', messages.length)

      // Log the first few messages for debugging
      console.log(
        'üìã First 3 messages:',
        messages.slice(0, 3).map((m) => ({
          role: m.role,
          content: m.content?.substring(0, 100) + '...',
        })),
      )

      // Run all analysis functions with individual error handling
      console.log('üîÑ Starting analysis requests...')
      
      // Run critical analysis functions first
      const [
        overview,
        trustAndOpenness,
        therapistEvaluation,
        behavioralAnalysis,
        emotionalAnalysis,
        thoughtsAndConcerns,
        psychoAnalysis,
        defenseMechanisms,
        schemas,
        demographicData,
        nextSteps,
        riskFactors,
      ] = await Promise.allSettled([
        getSessionOverview(messages),
        getTrustAndOpennessAnalysis(messages),
        getTherapistEvaluation(messages),
        getBehavioralAnalysis(messages),
        getEmotionalAnalysis(messages),
        getThoughtsAndConcerns(messages),
        getPsychoAnalysis(messages),
        getDefenseMechanisms(messages),
        getSchemas(messages),
        getDemographicData(messages),
        getNextSteps(messages),
        getRiskFactors(messages),
      ])

      // Process results and handle errors
      const results: any = {}
      
      // Helper function to process Promise.allSettled results
      const processResult = (result: PromiseSettledResult<any>, key: string, defaultValue: any = {}) => {
        if (result.status === 'fulfilled') {
          console.log(`‚úÖ ${key} analysis completed successfully`)
          return result.value
        } else {
          console.error(`‚ùå ${key} analysis failed:`, result.reason)
          // Return a default structure to prevent complete failure
          return defaultValue
        }
      }

      // Process each analysis with appropriate default values
      results.overview = processResult(overview, 'Session overview', {
        title: 'ÿ¨ŸÑÿ≥Ÿá ŸÖÿ¥ÿßŸàÿ±Ÿá',
        summaryOfSession: 'ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß€å ÿ™ÿ≠ŸÑ€åŸÑÿå ÿÆŸÑÿßÿµŸá ÿ¨ŸÑÿ≥Ÿá ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        headlines: []
      })
      
      results.trustAndOpenness = processResult(trustAndOpenness, 'Trust and openness', {
        finalTrustAndOppennessOfUser: 'unknown',
        finalTrustAndOppennessOfUserEvaluationDescription: 'ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß€å ÿ™ÿ≠ŸÑ€åŸÑÿå ÿßÿ±ÿ≤€åÿßÿ®€å ÿ≥ÿ∑ÿ≠ ÿßÿπÿ™ŸÖÿßÿØ ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        trustLevelProgression: [],
        opennessLevelProgression: []
      })
      
      results.therapistEvaluation = processResult(therapistEvaluation, 'Therapist evaluation', {
        psychotherapistEvaluation: 'ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß€å ÿ™ÿ≠ŸÑ€åŸÑÿå ÿßÿ±ÿ≤€åÿßÿ®€å ÿπŸÖŸÑ⁄©ÿ±ÿØ ÿ±ŸàÿßŸÜÿ¥ŸÜÿßÿ≥ ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        negativeScoresList: [],
        psychotherapistEvaluationScorePositiveBehavior: [],
        psychotherapistEvaluationScoreSuggestionsToImprove: []
      })
      
      results.behavioralAnalysis = processResult(behavioralAnalysis, 'Behavioral analysis', {
        behavioralAnalysisSummary: 'ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß€å ÿ™ÿ≠ŸÑ€åŸÑÿå ÿ™ÿ≠ŸÑ€åŸÑ ÿ±ŸÅÿ™ÿßÿ±€å ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™'
      })
      
      results.emotionalAnalysis = processResult(emotionalAnalysis, 'Emotional analysis', {
        emotionalAnalysisSummary: 'ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß€å ÿ™ÿ≠ŸÑ€åŸÑÿå ÿ™ÿ≠ŸÑ€åŸÑ ÿßÿ≠ÿ≥ÿßÿ≥€å ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™'
      })
      
      results.thoughtsAndConcerns = processResult(thoughtsAndConcerns, 'Thoughts and concerns', {
        thoughtsAndConcernsSummary: 'ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß€å ÿ™ÿ≠ŸÑ€åŸÑÿå ÿÆŸÑÿßÿµŸá ÿßŸÅ⁄©ÿßÿ± Ÿà ŸÜ⁄Øÿ±ÿßŸÜ€å‚ÄåŸáÿß ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™'
      })
      
      results.psychoAnalysis = processResult(psychoAnalysis, 'Psycho analysis', {
        psychoAnalysis: 'ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß€å ÿ™ÿ≠ŸÑ€åŸÑÿå ÿ™ÿ≠ŸÑ€åŸÑ ÿ±ŸàÿßŸÜ⁄©ÿßŸà€å ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        possibleDeeperGoalsOfPatient: 'ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß€å ÿ™ÿ≠ŸÑ€åŸÑÿå ÿßŸáÿØÿßŸÅ ÿπŸÖ€åŸÇ‚Äåÿ™ÿ± ÿ®€åŸÖÿßÿ± ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™'
      })
      
      results.defenseMechanisms = processResult(defenseMechanisms, 'Defense mechanisms', {
        detectedDefenceMechanisms: []
      })
      
      results.schemas = processResult(schemas, 'Schemas', {
        detectedSchemas: []
      })
      
      results.demographicData = processResult(demographicData, 'Demographic data', {
        demographicData: {
          firstName: null,
          lastName: null,
          age: null,
          gender: null,
          education: null,
          occupation: null,
          maritalStatus: null
        }
      })
      
      results.nextSteps = processResult(nextSteps, 'Next steps', {
        suggestedNextStepsForTherapistForNextSession: []
      })
      
      results.riskFactors = processResult(riskFactors, 'Risk factors', {
        possibleRiskFactorsExtracted: []
      })

      // Combine all results into a single object
      console.log('üîÑ Combining analysis results...')
      const combinedResult = {
        ...results.overview,
        ...results.trustAndOpenness,
        ...results.therapistEvaluation,
        ...results.behavioralAnalysis,
        ...results.emotionalAnalysis,
        ...results.thoughtsAndConcerns,
        ...results.psychoAnalysis,
        ...results.defenseMechanisms,
        ...results.schemas,
        ...results.demographicData,
        ...results.nextSteps,
        ...results.riskFactors,
      }

      // Validate required fields and provide defaults if missing
      const validatedResult = {
        title: combinedResult.title || 'ÿ¨ŸÑÿ≥Ÿá ŸÖÿ¥ÿßŸàÿ±Ÿá',
        summaryOfSession: combinedResult.summaryOfSession || 'ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß€å ÿ™ÿ≠ŸÑ€åŸÑÿå ÿÆŸÑÿßÿµŸá ÿ¨ŸÑÿ≥Ÿá ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        headlines: combinedResult.headlines || [],
        finalTrustAndOppennessOfUser: combinedResult.finalTrustAndOppennessOfUser || 'unknown',
        finalTrustAndOppennessOfUserEvaluationDescription: combinedResult.finalTrustAndOppennessOfUserEvaluationDescription || 'ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß€å ÿ™ÿ≠ŸÑ€åŸÑÿå ÿßÿ±ÿ≤€åÿßÿ®€å ÿ≥ÿ∑ÿ≠ ÿßÿπÿ™ŸÖÿßÿØ ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        trustLevelProgression: combinedResult.trustLevelProgression || [],
        opennessLevelProgression: combinedResult.opennessLevelProgression || [],
        psychotherapistEvaluation: combinedResult.psychotherapistEvaluation || 'ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß€å ÿ™ÿ≠ŸÑ€åŸÑÿå ÿßÿ±ÿ≤€åÿßÿ®€å ÿπŸÖŸÑ⁄©ÿ±ÿØ ÿ±ŸàÿßŸÜÿ¥ŸÜÿßÿ≥ ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        negativeScoresList: combinedResult.negativeScoresList || [],
        psychotherapistEvaluationScorePositiveBehavior: combinedResult.psychotherapistEvaluationScorePositiveBehavior || [],
        psychotherapistEvaluationScoreSuggestionsToImprove: combinedResult.psychotherapistEvaluationScoreSuggestionsToImprove || [],
        behavioralAnalysisSummary: combinedResult.behavioralAnalysisSummary || 'ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß€å ÿ™ÿ≠ŸÑ€åŸÑÿå ÿ™ÿ≠ŸÑ€åŸÑ ÿ±ŸÅÿ™ÿßÿ±€å ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        emotionalAnalysisSummary: combinedResult.emotionalAnalysisSummary || 'ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß€å ÿ™ÿ≠ŸÑ€åŸÑÿå ÿ™ÿ≠ŸÑ€åŸÑ ÿßÿ≠ÿ≥ÿßÿ≥€å ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        thoughtsAndConcernsSummary: combinedResult.thoughtsAndConcernsSummary || 'ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß€å ÿ™ÿ≠ŸÑ€åŸÑÿå ÿÆŸÑÿßÿµŸá ÿßŸÅ⁄©ÿßÿ± Ÿà ŸÜ⁄Øÿ±ÿßŸÜ€å‚ÄåŸáÿß ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        psychoAnalysis: combinedResult.psychoAnalysis || 'ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß€å ÿ™ÿ≠ŸÑ€åŸÑÿå ÿ™ÿ≠ŸÑ€åŸÑ ÿ±ŸàÿßŸÜ⁄©ÿßŸà€å ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        possibleDeeperGoalsOfPatient: combinedResult.possibleDeeperGoalsOfPatient || 'ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß€å ÿ™ÿ≠ŸÑ€åŸÑÿå ÿßŸáÿØÿßŸÅ ÿπŸÖ€åŸÇ‚Äåÿ™ÿ± ÿ®€åŸÖÿßÿ± ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        detectedDefenceMechanisms: combinedResult.detectedDefenceMechanisms || [],
        detectedSchemas: combinedResult.detectedSchemas || [],
        demographicData: combinedResult.demographicData || {
          firstName: null,
          lastName: null,
          age: null,
          gender: null,
          education: null,
          occupation: null,
          maritalStatus: null
        },
        suggestedNextStepsForTherapistForNextSession: combinedResult.suggestedNextStepsForTherapistForNextSession || [],
        possibleRiskFactorsExtracted: combinedResult.possibleRiskFactorsExtracted || [],
        ...combinedResult
      }

      console.log('‚úÖ Session analysis generation completed successfully')
      return validatedResult
    } catch (e: any) {
      console.error('üí• Critical error in generateAnalysis:', e)
      error.value = e.message
      
      // Return a default analysis structure to prevent complete failure
      const defaultAnalysis = {
        title: 'ÿ¨ŸÑÿ≥Ÿá ŸÖÿ¥ÿßŸàÿ±Ÿá',
        summaryOfSession: 'ÿ®Ÿá ÿØŸÑ€åŸÑ ÿ®ÿ±Ÿàÿ≤ ÿÆÿ∑ÿßÿå ÿÆŸÑÿßÿµŸá ÿ¨ŸÑÿ≥Ÿá ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        headlines: [],
        finalTrustAndOppennessOfUser: 'unknown',
        finalTrustAndOppennessOfUserEvaluationDescription: 'ÿßÿ±ÿ≤€åÿßÿ®€å ÿ≥ÿ∑ÿ≠ ÿßÿπÿ™ŸÖÿßÿØ ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        trustLevelProgression: [],
        opennessLevelProgression: [],
        psychotherapistEvaluation: 'ÿßÿ±ÿ≤€åÿßÿ®€å ÿπŸÖŸÑ⁄©ÿ±ÿØ ÿ±ŸàÿßŸÜÿ¥ŸÜÿßÿ≥ ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        negativeScoresList: [],
        psychotherapistEvaluationScorePositiveBehavior: [],
        psychotherapistEvaluationScoreSuggestionsToImprove: [],
        behavioralAnalysisSummary: 'ÿ™ÿ≠ŸÑ€åŸÑ ÿ±ŸÅÿ™ÿßÿ±€å ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        emotionalAnalysisSummary: 'ÿ™ÿ≠ŸÑ€åŸÑ ÿßÿ≠ÿ≥ÿßÿ≥€å ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        thoughtsAndConcernsSummary: 'ÿÆŸÑÿßÿµŸá ÿßŸÅ⁄©ÿßÿ± Ÿà ŸÜ⁄Øÿ±ÿßŸÜ€å‚ÄåŸáÿß ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        psychoAnalysis: 'ÿ™ÿ≠ŸÑ€åŸÑ ÿ±ŸàÿßŸÜ⁄©ÿßŸà€å ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        possibleDeeperGoalsOfPatient: 'ÿßŸáÿØÿßŸÅ ÿπŸÖ€åŸÇ‚Äåÿ™ÿ± ÿ®€åŸÖÿßÿ± ÿ®Ÿá ÿØŸÑ€åŸÑ ÿÆÿ∑ÿß ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™',
        detectedDefenceMechanisms: [],
        detectedSchemas: [],
        demographicData: {
          firstName: null,
          lastName: null,
          age: null,
          gender: null,
          education: null,
          occupation: null,
          maritalStatus: null
        },
        suggestedNextStepsForTherapistForNextSession: [],
        possibleRiskFactorsExtracted: []
      }
      
      return defaultAnalysis
    } finally {
      processing.value = false
      console.log('üèÅ generateAnalysis function completed')
    }
  }

  const getAnalysisForSession = async (
    sessionId: string,
  ): Promise<SessionAnalysis | null> => {
    try {
      const nuxtApp = useNuxtApp()
      const records = await nuxtApp.$pb
        .collection('session_analysis_for_system')
        .getList(1, 1, {
          filter: `session="${sessionId}"`,
          sort: '-created',
          expand: 'session',
        })

      if (records.items.length > 0) {
        return records.items[0] as unknown as SessionAnalysis
      }
      return null
    } catch (error: any) {
      if (error?.status === 404) {
        return null
      }
      console.error('Error getting analysis for session:', error)
      throw error
    }
  }

  return {
    error,
    processing,
    createAnalysis,
    getAnalysisById,
    listAnalysis,
    updateAnalysis,
    deleteAnalysis,
    generateAnalysis,
    getAnalysisForSession,
  }
}
