{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const fs=require(\"graceful-fs\");const path=require(\"path\");const mkdirsSync=require(\"../mkdirs\").mkdirsSync;const utimesMillisSync=require(\"../util/utimes\").utimesMillisSync;const stat=require(\"../util/stat\");function copySync(src,dest,opts){if(typeof opts===\"function\"){opts={filter:opts}}opts=opts||{};opts.clobber=\"clobber\"in opts?!!opts.clobber:true;opts.overwrite=\"overwrite\"in opts?!!opts.overwrite:opts.clobber;if(opts.preserveTimestamps&&process.arch===\"ia32\"){process.emitWarning(\"Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n\tsee https://github.com/jprichardson/node-fs-extra/issues/269\",\"Warning\",\"fs-extra-WARN0002\")}const{srcStat,destStat}=stat.checkPathsSync(src,dest,\"copy\",opts);stat.checkParentPathsSync(src,srcStat,dest,\"copy\");if(opts.filter&&!opts.filter(src,dest))return;const destParent=path.dirname(dest);if(!fs.existsSync(destParent))mkdirsSync(destParent);return getStats(destStat,src,dest,opts)}__name(copySync,\"copySync\");function getStats(destStat,src,dest,opts){const statSync=opts.dereference?fs.statSync:fs.lstatSync;const srcStat=statSync(src);if(srcStat.isDirectory())return onDir(srcStat,destStat,src,dest,opts);else if(srcStat.isFile()||srcStat.isCharacterDevice()||srcStat.isBlockDevice())return onFile(srcStat,destStat,src,dest,opts);else if(srcStat.isSymbolicLink())return onLink(destStat,src,dest,opts);else if(srcStat.isSocket())throw new Error(`Cannot copy a socket file: ${src}`);else if(srcStat.isFIFO())throw new Error(`Cannot copy a FIFO pipe: ${src}`);throw new Error(`Unknown file: ${src}`)}__name(getStats,\"getStats\");function onFile(srcStat,destStat,src,dest,opts){if(!destStat)return copyFile(srcStat,src,dest,opts);return mayCopyFile(srcStat,src,dest,opts)}__name(onFile,\"onFile\");function mayCopyFile(srcStat,src,dest,opts){if(opts.overwrite){fs.unlinkSync(dest);return copyFile(srcStat,src,dest,opts)}else if(opts.errorOnExist){throw new Error(`'${dest}' already exists`)}}__name(mayCopyFile,\"mayCopyFile\");function copyFile(srcStat,src,dest,opts){fs.copyFileSync(src,dest);if(opts.preserveTimestamps)handleTimestamps(srcStat.mode,src,dest);return setDestMode(dest,srcStat.mode)}__name(copyFile,\"copyFile\");function handleTimestamps(srcMode,src,dest){if(fileIsNotWritable(srcMode))makeFileWritable(dest,srcMode);return setDestTimestamps(src,dest)}__name(handleTimestamps,\"handleTimestamps\");function fileIsNotWritable(srcMode){return(srcMode&128)===0}__name(fileIsNotWritable,\"fileIsNotWritable\");function makeFileWritable(dest,srcMode){return setDestMode(dest,srcMode|128)}__name(makeFileWritable,\"makeFileWritable\");function setDestMode(dest,srcMode){return fs.chmodSync(dest,srcMode)}__name(setDestMode,\"setDestMode\");function setDestTimestamps(src,dest){const updatedSrcStat=fs.statSync(src);return utimesMillisSync(dest,updatedSrcStat.atime,updatedSrcStat.mtime)}__name(setDestTimestamps,\"setDestTimestamps\");function onDir(srcStat,destStat,src,dest,opts){if(!destStat)return mkDirAndCopy(srcStat.mode,src,dest,opts);return copyDir(src,dest,opts)}__name(onDir,\"onDir\");function mkDirAndCopy(srcMode,src,dest,opts){fs.mkdirSync(dest);copyDir(src,dest,opts);return setDestMode(dest,srcMode)}__name(mkDirAndCopy,\"mkDirAndCopy\");function copyDir(src,dest,opts){fs.readdirSync(src).forEach(item=>copyDirItem(item,src,dest,opts))}__name(copyDir,\"copyDir\");function copyDirItem(item,src,dest,opts){const srcItem=path.join(src,item);const destItem=path.join(dest,item);if(opts.filter&&!opts.filter(srcItem,destItem))return;const{destStat}=stat.checkPathsSync(srcItem,destItem,\"copy\",opts);return getStats(destStat,srcItem,destItem,opts)}__name(copyDirItem,\"copyDirItem\");function onLink(destStat,src,dest,opts){let resolvedSrc=fs.readlinkSync(src);if(opts.dereference){resolvedSrc=path.resolve(process.cwd(),resolvedSrc)}if(!destStat){return fs.symlinkSync(resolvedSrc,dest)}else{let resolvedDest;try{resolvedDest=fs.readlinkSync(dest)}catch(err){if(err.code===\"EINVAL\"||err.code===\"UNKNOWN\")return fs.symlinkSync(resolvedSrc,dest);throw err}if(opts.dereference){resolvedDest=path.resolve(process.cwd(),resolvedDest)}if(stat.isSrcSubdir(resolvedSrc,resolvedDest)){throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)}if(stat.isSrcSubdir(resolvedDest,resolvedSrc)){throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)}return copyLink(resolvedSrc,dest)}}__name(onLink,\"onLink\");function copyLink(resolvedSrc,dest){fs.unlinkSync(dest);return fs.symlinkSync(resolvedSrc,dest)}__name(copyLink,\"copyLink\");module.exports=copySync;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/Users/mac/Tommy/Nuxt/node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/copy/copy-sync.js"],"sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirsSync = require('../mkdirs').mkdirsSync\nconst utimesMillisSync = require('../util/utimes').utimesMillisSync\nconst stat = require('../util/stat')\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning(\n      'Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' +\n      '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269',\n      'Warning', 'fs-extra-WARN0002'\n    )\n  }\n\n  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy', opts)\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy')\n  if (opts.filter && !opts.filter(src, dest)) return\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirsSync(destParent)\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n  else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)\n  else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)\n  throw new Error(`Unknown file: ${src}`)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  fs.copyFileSync(src, dest)\n  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest)\n  return setDestMode(dest, srcStat.mode)\n}\n\nfunction handleTimestamps (srcMode, src, dest) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode)\n  return setDestTimestamps(src, dest)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200)\n}\n\nfunction setDestMode (dest, srcMode) {\n  return fs.chmodSync(dest, srcMode)\n}\n\nfunction setDestTimestamps (src, dest) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  const updatedSrcStat = fs.statSync(src)\n  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts)\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcMode, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return setDestMode(dest, srcMode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  if (opts.filter && !opts.filter(srcItem, destItem)) return\n  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy', opts)\n  return getStats(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\nmodule.exports = copySync\n"]}}